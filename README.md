# Web Notes

- [Use](#Use)
- [Git](#Git)
- [JavaScript](#JavaScript)
  - [ECMAScript](#ECMAScript)
    - [JS 2021](#js-2021)
    - [EventLoop](#EventLoop)
      - [Стек](#Стек)
      - [Очередь](#Очередь)
      - [Куча](#Куча)
    - [Микрозадачи, Макрозадачи](#Микрозадачи-Макрозадачи)
    - [Hint](#Hint)
  - [IIFE](#IIFE)
  - [Классы](#Классы)
  - [Контекст](#Контекст)
  - [Декларативное, Императивное программирование](#Декларативное-Императивное-программирование)
  - [Declaration, Expression Function](#Declaration-Expression-Function)
  - [Анонимная функция](#Анонимная-функция)
  - [JSON](#JSON)
  - [use strict](#use-strict)
  - [Генераторы](#Генераторы)
  - [Шаблонные литералы](#Шаблонные-литералы)
  - [Promise](#Promise)
  - [Код](#Код)
  - [W3C DOM Events](#W3C-DOM-Events)
  - [Деструктуризация](#Деструктуризация)
  - [Тернарный оператор](#Тернарный-оператор)
  - [Динамический ключ](#Динамический-ключ)
  - [Прототипы](#Прототипы)
  - [Операторы](#Операторы)
  - [Чистая функция](#Чистая-функция)
  - [freeze](#freeze)
  - [Дескрипторы](#Дескрипторы)
  - [Reflect](#Reflect)
  - [Proxy](#Proxy)
  - [??](#??)
  - [?.](#?.)
  - [Типы данных](#Типы-данных)
  - [new](#new)
  - [delete](#delete)
  - [reduce](#reduce)
  - [for](#for)
  - [Регулярные выражения](#Регулярные-выражения)
- [Technology](#Technology)
  - [React](#React)
    - [Хук](#Хук)
      - [useState](#useState)
      - [useEffect](#useEffect)
      - [useContext](#useContext)
      - [useCallback](#useCallback) -[React Router](#React-Router)
    - [JSX](#JSX)
    - [React DevTools](#React-DevTools)
    - [React Native](#React-Native)
  - [NestJS](#NestJS)
  - [Node.js](#Node.js)
    - [npm](#npm)
    - [npx](#npx)
  - [Express](#Express)
  - [GraphQL](#GraphQL)
  - [Docker](#Docker)
  - [TypeORM](#TypeORM)
  - [Next.js](#Next.js)
  - [Babel](#Babel)
  - [Material Design](#Material-Design)
  - [Axios](#Axios)
  - [Lodash](#Lodash)
  - [Webpack](#Webpack)
  - [JScript](#JScript)
  - [CoffeeScript](#CoffeeScript)
  - [Flow](#Flow)
  - [Dart](#Dart)
  - [Angular](#Angular)
  - [AngularJS](#AngularJS)
  - [RxJS](#RxJS)
  - [Open Server](#Open-Server)
  - [Xampp](#Xampp)
  - [Electron JS](#Electron-JS)
  - [Cleave.js](#Cleave.js)
  - [Emmet](#Emmet)
  - [JSON Web Token (JWT)](#JSON-Web-Token-JWT)
  - [Nx](#Nx)
  - [Meteor](#Meteor)
  - [WebSocket](#WebSocket)
  - [Контейнеризация](#Контейнеризация)
  - [Markdown](#Markdown)
- [Stacks](#Stacks)
  - [MERN](#MERN)
- [Flux-архитектура](#Flux-архитектура)
- [Автотесты](#Автотесты)
- [Принципы](#Принципы)
  - [Принципы, схемы и подходы программирования](#Принципы-схемы-и-подходы-программирования)
    - [Соглашения JavaScript](#Соглашения-JavaScript)
    - [MVC](#MVC)
      - [Модель](#Модель)
      - [Представление](#Представление)
      - [Контроллер](#Контроллер)
    - [SOLID](#SOLID)
    - [KISS](#KISS)
    - [DRY](#DRY)
    - [YAGNI](#YAGNI)
    - [Паттерны проектирования](#Паттерны-проектирования)
  - [Реактивное программирование](#Реактивное-программирование)
  - [SaaS](#SaaS)
- [IDE](#IDE)
  - [VSCode](#VSCode)
  - [WebStorm](#WebStorm)
- [Генератор документации](#Генератор-документации)
- [Облачные сервисы](#Облачные-сервисы)
- [API](#API)
  - [REST, Open API](#REST-Open-API)
- [Транспиляция](#Транспиляция)
  - [Bundle](#Bundle)
- [Cookie](#Cookie)
- [Определения](#Определения)
  - [Нативный](#Нативный)
  - [Адаптивность, Отзывчивость](#Адаптивность-Отзывчивость)
  - [Accessibility](#Accessibility)
  - [#Семантика](#Семантика)
  - [Layout](#Layout)
  - [Legacy code](#Legacy-code)
  - [Миксин](#Миксин)
  - [Палиндром](#Палиндром)
  - [Сборка мусора](#Сборка-мусора)
  - [Веб-безопасность](#Веб-безопасность)
  - [Полифил](#Полифил)
  - [Микросервис](#Микросервис)
  - [SSR](#SSR)
  - [SEO](#SEO)
- [HTML](#HTML)
- [CSS](#CSS)
  - [БЭМ](#БЭМ)
- [Шрифты](#Шрифты)
- [Typescript](#Typescript)
  - [enum](#enum)
- [Браузер](#Браузер)
- [Алгоритмы и структуры данных](#Алгоритмы-и-структуры-данных)
- [NoSQL](#NoSQL)
  - [MongoDB](#MongoDB)
  - [Redis](#Redis)
- [Брокер](#Брокер)
- [Процесс разработки программного обеспечения, Жизненный цикл, MVP](#Процесс-разработки-программного-обеспечения-Жизненный-цикл-MVP)

## Use

- #Соглашения JavaScript
- #React
- #MobX
- #NestJS
- #Typeorm
- #GraphQL
- #Swagger
- #Typescript
- #Jest
- [Git](#Git)
- #MVC
- #Material Design
- #WebSocket
- #Docker
- #SASS
- #VSCode #VSCodeРасширения
- #JSDoc и readme.md
- #БЭМ

## Git

`#Git`

Git (произносится «гит») — распределённая система управления версиями.

https://ru.wikipedia.org/wiki/Git

Офф: https://git-scm.com/docs

Atlassian: https://www.atlassian.com/ru/git/tutorials/setting-up-a-repository

https://youtu.be/zZBiln_2FhM

https://habr.com/ru/post/106912

Путь от и до: https://rustycrate.ru/руководства/2016/03/07/contributing.html

Плагин для Chrome - Octotree - GitHub code tree: https://chrome.google.com/webstore/detail/octotree-github-code-tree/bkhaagjahfmjljalopjnoealnfndnagc?hl=ru

### Обозначения

Repository - репозиторий, в нём находится весь проект, как правило ему задаём имя upstream

Branch - ветка

Fork - ответвление, копия репозитория (в переводе вилка). Запрос на слияние форков и будет pull request

HEAD - последний коммит в ветке, можно юзать везде, где указывается id

origin - имя текущего репозитория. Указывается в команде git remote add для работы со своим репозиторием / форкой. Создаётся при git clone

upstream - имя основной серверной репы. Указывается в команде git remote add для работы с репой источником, исходником, оригиналом

master - основная ветка в репе, которая создаётся автоматом вместе с репой

. - все, например, файлы

& - для перечисления нескольких команд git и cmd. В powershell для перечисления нескольких команд используется точка с запятой

### Персональные данные

git config --global user.name <"name"> - если name не указан, выведет текущий UserName, иначе задаст его

git config --global user.email <"email"> - если email не указан, выведет текущий UserEmail, иначе задаст его

git config --global http.sslverify false - отключить использование сертификата

### Общие

git --version - версия

git --help - список команд

gitk --all& - графический интерфейс гита

.gitignore - файл для объектов исключений, которые не будем добавлять в отслеживание, проект

### Проект

#clone: git clone <remote_url> - скопировать содержимое проекта. В текущую папку git clone <remote_url> . - с точкой вконце, скопирует содержимое в корень текущей директории, не создавая папку. Команда создаёт скрытую системную папку ".git" и делает git add origin

git init - инициализация проекта. Команда создаёт скрытую системную папку ".git"

git remote add <remote_name> <remote_url> - привязать проект remote_url к названию remote_name. Не ветке, просто названию, чтобы не писать длинную ссылку постоянно. Например remote_name = origin

git remote show <remote_name> - показать информацию об удалённом репозитории, ветке, HEAD и т д

git remote -v - покажет все добавленные remote_url и их remote_name

git remote rm <remote_name> - удалить привязку remote_name к remote_url из списка

### Комбо

#Персональные данные: git config --global user.name "name" & git config --global user.email "email" & git config --global http.sslverify false

Init & GitHub: git init & git add . & git commit -m "First commit" & git branch -M main & git remote add origin https://github.com/SpawnMetal/lib.git & git push -u origin main

#Файлы Update: git add . & git commit -m "Updated date" & git push

#Файлы Синхронизация: git add . & git commit -m "" & git pull origin <branch> & git push

#Ветки Удаление ветки: git checkout develop & git branch -d <branch> & git push <remote_name> <branch> --delete

### Файлы

git push -u <remote_name> <branch> - Заливает новую branch в remote_name. Создаёт pull request, если ветка уже есть. -u -это upstream, мол сервер. Например выполнив команду git push -u origin master вы устанавливаете связь между той веткой, в которой вы находитесь и веткой master на удалённом сервере. Команду требуется выполнить единожды, чтобы потом можно было отправлять/принимать изменения лишь выполняя git push из ветки без указания всяких алиасов для сервера и удалённых веток. Это сделано для удобства.

git push - залить в текущую ветку на сервер, ранее должна быть установлена связь git push -u

git push <remote_name> <branch> - заливает изменения по <remote_name> в <branch>

Флаг --force отменяет необходимость в pull и подгоняет ветку удаленного репозитория под вашу локальную ветку, удаляя любые вышестоящие изменения, которые могли быть внесены с момента последнего выполнения вами команды pull.

git pull <remote_name> <branch> - шоткод для команд git fetch и git merge. <remote_name> и <branch> по умолчанию текущие. Получит с сервера и объединит с локальной.
При работе с fork не забывать пуллить свою форку с remote.

--rebase либо git rebase - Перебазирует ветку на текущий и дальнейшие коммиты, которые будут попадать в историю коммитов (например master) на момент её слияния с перебазированной веткой (develop), а не на момент создания коммита в прошлом.
Т.е. коммит сделанный 3 года назад в develop, при слиянии попадёт в самый верх коммитов master. См. Commits on Jun 22, 2022 https://github.com/SpawnMetal/examples/commits/master
Использовать при пулле из upstream в origin https://www.atlassian.com/ru/git/tutorials/syncing/git-pull

git rebase --skip позволит пропустить конфликт при git rebase, для каждого конфликта команда вводится отдельно

git add <file> или . - добавляет file или все файлы в отслеживаемые для добавления в коммит. Несколько перечисляются через пробел.

git fetch <remote_name> <branch> - получить изменения, но не делать слияние - git merge.

git merge <branch> - объединить скачанные изменения с текущей веткой, либо branch, если указана, в таком случае из branch будут получены все изменения

git commit -m <text> - зафиксировать отслеживаемые файлы, создав коммит. -m = -message. text указывается в двойных кавычках. После ввода команды будет выведен хэш коммита

git show <id> просмотр информации о теге, коммите, ветке

git status - показать текущую ветку и изменённые файлы

git clone см #clone

git checkout <id>, <file> либо <tag> - переключиться на id коммита, tag либо откатить файл до индекса. Работает с тремя различными объектами: файлами, коммитами и ветками. Команда открепляет HEAD, что не позволит сохранить изменения при неизбежном переключении обратно в ветку.

Удалить индексы, не файлы, код не бэкапнется. Несколько файлов перечисляются через пробел:
git reset <file>

git rm --cached <file>

git rm -r .

git reset --hard id либо origin/master - откатит код до коммита id либо ветки origin/master, стерев историю

git restore <file> - откатит до коммита (бэкапнет код) не проиндексированные файлы, проиндексированные сначала отменить: git reset <file>

git restore --source <id_коммита> <file> - откатит код до коммита id сохранив историю, создав новый коммит

git show <commit_id> - покажет информацию о коммите и его полный id

git commit --amend -m "" - переименовать либо отредактировать текст последнего коммита

git log -кол-во --pretty=oneline - покажет информацию по кол-ву последних коммитов, теги, сообщения коммитов, HEAD. Напротив последней залитой будет красным написано origin/branch

get tag -a - аннотированный тег, некое название коммита https://www.atlassian.com/ru/git/tutorials/inspecting-a-repository/git-tag https://git-scm.com/book/ru/v2/Основы-Git-Работа-с-метками

git tag -a v1.0.1 -m "" - создать тег

git tag -a -f <tag> -m "" <id> - переименовать тег у коммита id

git tag -a <tag> <id> - задать тег любому коммиту id

git tag - просмотр списка тегов

git show <tag> просмотр информации о теге, коммите, ветке

git tag -d <tag> - удалить тег

### Ветки

git branch - выводит список веток и ветку в которой я нахожусь. В VSCode слева снизу

git branch <branch> - создаст ветку name, копию текущей

git branch -d <branch> - удалит ветку name локально. Необходимо сначала переключиться на другую. -D, если необходимо удалить принудительно (--force)

git pull origin develop - скачать новую ветку с сервера

git push <remote_name> <branch> --delete - удаляет ветку на сервере

git branch -m <branch> - переименовать текущую ветку в name, -M, если необходимо переименовать, даже если такая ветка уже сушествует

git checkout <branch> - переключиться на ветку name

git checkout -b <branch> - создать и переключиться на ветку name, копию текущей

git checkout -b <branch> <remote_name> - создать и переключиться на ветку branch, ответвление от name_from

git checkout -b <branch> <repository_name_from>/<branch> - скопировать удалённую ветку и переключиться в неё

git push -u <remote_name> <branch> - Заливает НОВУЮ!!! branch в remote_name. Создаёт pull request при необходимости. -u: upstream. remote_name: название ссылки, которое устанавливал с помощью git remote add <remote_name> <remote_url>. branch: ветка, которую будем заливать.

git show <branch> просмотр информации о теге, коммите, ветке

#### Release branches

Ветви релизов (release branches) используются для подготовки к выпуску новых версий продукта.

Могут порождаться от: develop

Должны вливаться в: develop и master

Соглашение о наименовании: release-\*

#### Hotfix branches

Они порождаются необходимостью немедленно исправить нежелательное поведение производственной версии продукта.

Могут порождаться от: master

Должны вливаться в: develop и master

Соглашение о наименовании: hotfix-\*

#### Feature branches

Ветви функциональностей (feature branches) обычно существуют в репозиториях разработчиков (origin), но не в главном репозитории (upstream).

Соглашение о наименовании: всё, за исключением master, develop, release-_ или hotfix-_

Могут пораждаться от develop

Должны вливаться в develop

### Откат изменений

https://www.atlassian.com/ru/git/tutorials/undoing-changes

Локально:

Отменить индексирование (add): git reset <file>. Код не бэкапнется. Ещё можно git rm --cached <file> или -r . - удалить file или файлы рекурсивно из отслеживаемых. Несколько перечисляются через пробел

Откатить до индекса: git checkout <file>

Откатить до коммита: git restore

Удалить из индексирования и откатить до коммита всё и без вопросов: git reset . --quiet & git restore .

При pull, если необходимо отменить всё: git clean -f, ээфект такой же, как при git checkout другая_ветка --force, затем переключаемся обратно

Откат изменений до коммита либо к ветке, например master (полностью скачивает и заменяет коммиты, стерев историю, можно из upstream и т. д.): git reset --hard id либо origin/master

Название коммита: Как изменить название последнего локального коммита либо внести в него изменения? git commit --amend -m ""

Удалить ветку: git branch -d <branch>

Remote:

Удалить ветку: git push <remote_name> <branch> --delete

Локально и remote:

Откатить до коммита с удалением истории. Использовать в своей репе и ветке. В upstream убедиться, что удалённые коммиты уже не скачаны остальными: git reset --hard id & git push --force

Удалить все коммиты, включая самый первый: git update-ref -d HEAD, затем всё коммитим и git push --force

Откатить файлы к коммиту, сохранив историю, как если бы скачали коммит и этими файлами заменили свои: git restore --source <id_коммита> <file> & git push

### Vim, Vi

Вирусный редактор текста, работать в английской раскладке

https://youtu.be/6H0GDM8ExB8

esc - переход в командный режим

i - переход в режим редактирования текста

esc, Shift + Z два раза - сохранить и выйти, работать в английской раскладке

esc, Shift + ; пишем :q! - выйти без сохранения

## JavaScript

`#JavaScript #JS`

JavaScript - Мультипарадигменный (расширяемый и использующий другие языки) язык программирования. Поддерживает объектно-ориентированный, императивный и функциональный стили. Является реализацией языка ECMAScript. В него конвертируются: TypeScript, CoffeeScript, Flow, Dart.

JavaScript работает в одном потоке, поэтому об асинхронности не может быть речи, event loop и call stack сделали асинхронность возможной (сторонние API).

JavaScript интерпретируемый язык - выполняется сразу, в отличае от компиляции

### JS 2021

Конструкции наподобие a && (a = b) теперь можно записывать как a &&= b, a ||= b, a ??= b
Числа можно отделять с помощью \_, не влияя на их структуру 1000000000 === 1_000_000_000

### EventLoop

`#EventLoop`

https://developer.mozilla.org/ru/docs/Web/JavaScript/EventLoop

https://youtu.be/8aGhZQkoFbQ?t=773

Параллелизм/Многопоточность в JavaScript работает за счёт цикла событий (event loop), который отвечает за выполнение кода, сбора и обработки событий и выполнения подзадач из очереди (queued sub-tasks).

#### Стек

`#Stack #Стек`

Вызов любой функции создаёт контекст выполнения (Execution Context). При вызове вложенной функции создаётся новый контекст, а старый сохраняется в специальной структуре данных - стеке вызовов (Call Stack).

#### Очередь

`#Queue #Очередь`

Среда выполнения JavaScript содержит очередь задач. Эта очередь — список задач, подлежащих обработке. Каждая задача ассоциируется с некоторой функцией, которая будет вызвана, чтобы обработать эту задачу.
Когда стек полностью освобождается, самая первая задача извлекается из очереди и обрабатывается. Обработка задачи состоит в вызове ассоциированной с ней функции с параметрами, записанными в этой задаче. Как обычно, вызов функции создаёт новый контекст выполнения и заносится в стек вызовов.
Обработка задачи заканчивается, когда стек снова становится пустым. Следующая задача извлекается из очереди и начинается её обработка.

#### Куча

`#Heap #Куча`

Объекты размещаются в куче. Куча — это просто имя для обозначения большой неструктурированной области памяти.

### Микрозадачи, Макрозадачи

`#Микро #Макро #Микрозадачи #Макрозадачи`

https://learn.javascript.ru/event-loop

https://habr.com/ru/post/264993/

https://jakearchibald.com/2015/tasks-microtasks-queues-and-schedules/#why-this-happens

Порядок, сначала выполняются микрозадачи в рамках макрозадачи, затем очередь микрозадач:

- МАкрозадача
  - МИкрозадачИ
    - Очередь мИкрозадач
    - Очередь мАкрозадач

Может так случиться, что задача поступает, когда движок занят чем-то другим, тогда она ставится в очередь.

Очередь, которую формируют такие задачи, называют «очередью макрозадач» (macrotask queue, термин v8).

Вызов .then(func) у решённого промиса немедленно ставит в очередь микрозадачу. Вот почему promise1 и promise2 выводятся в журнал после script end, ведь текущий исполняемый сценарий должен завершиться до того как начнут обрабатываться микрозадачи. promise1 и promise2 выводятся в журнал до setTimeout ибо микрозадачи всегда развёртываются до следующей большой задачи.

Итого:

Сначала выполняются микрозадачи

setTimeout ставит в очередь большую задачу

promise ставит в очередь микрозадачу

В мире ECMAScript микрозадачи именуют заданиями («jobs»).

Если мы хотим запустить функцию асинхронно (после текущего кода), но до отображения изменений и до новых событий, то можем запланировать это через queueMicrotask.

Поэтому queueMicrotask можно использовать для асинхронного выполнения функции в том же состоянии окружения.

### Hint

`#Преобразование #Примитивы #Хинт #Hint`

Преобразование объектов в примитивы https://learn.javascript.ru/object-toprimitive

В отсутствие Symbol.toPrimitive и valueOf, toString обработает все примитивные преобразования.

Сначала вызывается метод obj[Symbol.toPrimitive](hint), если он существует,

В случае, если хинт равен "string" происходит попытка вызвать obj.toString() и obj.valueOf(), смотря что есть.

В случае, если хинт равен "number" или "default" происходит попытка вызвать obj.valueOf() и obj.toString(), смотря что есть.

Все эти методы должны возвращать примитив (если определены).

### ECMAScript

`#ECMAScript #ES`

ECMAScript (ES, European Computer Manufacturers Association) - это встраиваемый расширяемый не имеющий средств ввода-вывода язык программирования, используемый в качестве основы для построения других скриптовых языков.

Расширения (реализации) языка: JavaScript, JScript, ActionScript, SpiderMonkey, V8.

ES6-8 https://youtu.be/Ti2Q4sQkNdU

ES2020 / JS2020 https://youtu.be/7TpAN4FISeI

## Technology

### React

https://reactjs.org

https://developer.mozilla.org/ru/docs/Learn/Tools_and_testing/Client-side_JavaScript_frameworks/React_getting_started

React (иногда React.js или ReactJS) — JavaScript-библиотека с открытым исходным кодом для разработки пользовательских интерфейсов. Разработчики Facebook.

В качестве библиотеки для разработки пользовательских интерфейсов React часто используется с другими библиотеками, такими как Redux либо Mobx.

Топ-10 библиотек для React на GitHub https://habr.com/ru/company/ruvds/blog/345060/

Material UI, React-Bootstrap https://react-bootstrap.github.io , Ant-Design, StoryBook, Gatsby, Enzyme, Blueprint, Spectacle, Elemental UI, Grommet, Mozaik

Пример GitHub https://github.com/SpawnMetal/test_with_questions

Пример локально localhost\test_with_questions

https://ru.reactjs.org/docs/create-a-new-react-app.html

https://create-react-app.dev

Create React App сразу всё ставит.

Create React App — удобная среда для изучения React и лучший способ начать создание нового одностраничного приложения на React.

Инструмент настраивает среду для использования новейших возможностей JavaScript, оптимизирует приложение для продакшена и обеспечивает комфорт во время разработки. Вам понадобятся Node.js не ниже версии 8.10 и npm не ниже версии 5.6 на вашем компьютере. Для создания проекта выполните команды:

- `npm install react-scripts@latest`: обновление инструментов
- `npm i react-router-dom`: для роутинга в react

React позволяет использовать synthetic events - обёртка эвентов для кроссбраузерности, накручивает свои механизмы.

Презентационный компоненты выводит данные и работает с props, а контейнер компонент формирует их для презентационного и работает с state.

В render нельзя менять состояние, иначе приложение уйдёт в рекурсию.

Если отнаследоваться от Pure Component, то React автоматически реализует shouldComponentUpdate, оптимизируя работу приложения.

Для оптимизации приложения используются shouldComponentUpdate, Pure component, React.memo() - для функциональных компонентов.

Для отрисовки компонентов используются функциональные компоненты, они более быстрые, но если нужны доступы до жизненных этапов в более сложном компоненте, тогда нужно использовать классовый компонент.

Хуки позволяют в функциональных компонентах взаимодействовать с жизненными этапами и механизмами React.
prop drilling - множественная передача пропсов, используется контекст, чтобы это избежать либо MobX.

Для валидации пропсов используется библиотека prop-types - динамическая типизация. Flow - для статической, аналог - Typescript

eject нужен, чтобы получить доступ к конфигурации приложения, если оно уже было настроено с помощью WebPack и настроить его отдельно.

PUBLIC_URL ведёт в папку public, Например <link rel="icon" href="%PUBLIC_URL%/favicon.ico" />

Если вы ищете полноценное решение, которое может валидировать ввод, запомнить посещённые поля формы и обработать её отправку, присмотритесь к Formik. Эта библиотека построена на принципах управляемых компонентов и управления состоянием, так что не пренебрегайте их изучением. https://ru.reactjs.org/docs/forms.html https://jaredpalmer.com/formik

- `npx create-react-app my-app`: установит тесты, git, webpack, babel и др

Примеры:

localhost\my-app пример create-react-app

localhost\react https://github.com/SpawnMetal/react

localhost\react2 https://github.com/SpawnMetal/react2 https://youtu.be/xJZa2_aldDs

#### Хук

`#Хук #Hook`

https://ru.reactjs.org/docs/hooks-intro.html

https://ru.reactjs.org/docs/hooks-reference.html

https://youtu.be/9KJxaFHotqI

Хуки — нововведение в React 16.8, которое позволяет использовать состояние и другие возможности React без написания классов.

По конвенции при создании своего хука функция должна начинаться с use

Хорошей практикой считается описание входящих свойств в нужный компонент, чтобы избегать потенциальных ошибок с передачей типов значений

Для этого раньше использовался `npm i prop-types`

##### useState

`#useState`

https://ru.reactjs.org/docs/hooks-reference.html#usestate

https://youtu.be/9KJxaFHotqI?t=71

Пример в localhost\react2 https://github.com/SpawnMetal/react2

const [state, setState] = useState(initialState)

Возвращает текущее значение в первом параметре деструктуризации и задаёт с помощью хука (второй параметр) начальное состояние значений.

Если в setState передаётся callback, то мы будем иметь доступ к предыдущенму значению: setState(prev => prev + 1)

Функция возвращает всегда два значения в массиве, первое - это дефолтное состояние, заданное сейчас, а второй элемент - коллбэк, с помощью него можно менять значения

##### useEffect

`#useEffect`

https://ru.reactjs.org/docs/hooks-reference.html#useeffect

https://youtu.be/9KJxaFHotqI?t=1400

componentDidMount. Чтобы функция отработала один раз, передаётся пустой массив вторым параметром. useEffect(() => {}, [])

componentDidMount + componentDidUpdate. Не передавать второй параметр. useEffect(() => {})

Для обновления, только при изменении значения useEffect(() => {}, state)
componentWillUnmount. Вернуть функцию. useEffect(() => {return () => {}})

Запускается после рендера и обновления.

При асинхронном получении данных не отображает для SEO

Передаётся два параметра, в первом коллбэк, во втором массив со списком зависимостей, чтобы отрабатывал коллбэк, переданный в первый параметр

Он выполняет ту же роль, что и componentDidMount, componentDidUpdate и componentWillUnmount в React-классах, объединив их в единый API.

##### useContext

`#useContext`

https://ru.reactjs.org/docs/hooks-reference.html#usecontext

Вы можете подписаться на контекст React без использования каких-либо вложений.

##### useCallback

`#useCallback`

https://www.youtube.com/watch?v=9KJxaFHotqI&t=3579s

Позволяет реализовать зависимость, при которой будет вызываться функция, наподобие второго аргумента в useEffect.

При setState происходит рендер компонента и при переданном useEffect callback'е он будет срабатывать из-за пересоздания функций в компоненте.

Таким образом будет вызываться callback лишний раз при вызове одного из setState в компоненте.

Чтобы этого избежать, мы оборачиваем callback в useCallback, тем самым как бы кэшируем функцию и при рендере компонента callback лишний раз вызываться не будет.

#### React DevTools

`#ReactDeveloperTools #DevTools`
https://github.com/facebook/react/tree/master/packages/react-devtools

React DevTools доступен как встроенное расширение для браузеров Chrome и Firefox. Этот пакет позволяет вам отлаживать приложение React в другом месте (например, в мобильном браузере, встроенном веб-просмотре, Safari внутри iframe).

Он работает как с React DOM, так и с React Native.

#### React Native

https://facebook.github.io/react-native

Вы можете использовать React Native сегодня в своих существующих проектах для Android и iOS, или вы можете создать совершенно новое приложение с нуля.

#### React Router

`#Router`

- `npm install --save react-router-dom`: DOM bindings for React Router. https://www.npmjs.com/package/react-router-dom

https://reacttraining.com/react-router

Для реализации алгоритмов навигации используется библиотека React Router.

React Router - популярная и полная библиотека маршрутизации для React.js, которая синхронизирует пользовательский интерфейс с URL-адресом. Он поддерживает ленивую загрузку кода, динамическое сопоставление маршрутов и обработку перехода по местоположению и первоначально был вдохновлен маршрутизатором Ember.

#### shouldComponentUpdate

`#shouldComponentUpdate`

Используется для отмены рендера, если его делать не нужно, а состояние поменялось

#### componentDidMount

`#componentDidMount`

Срабатывает, когда компонент готов для работы. После этого можно использовать асинхрон.

#### React Fragment

`#ReactFragment #Fragment`

Используется, чтобы положить несколько элементов в один конейнер, например div, но сам div отображаться не будет, оптимизируя тем самым структуру dom

```html
<React.Fragment> Элементы </React.Fragment>
```

Так же можно использовать структуру `<></>`

### Next.js

`#Next.js`

```
npx create-next-app
```

Пример 1: localhost/create-next-app https://github.com/SpawnMetal/create-next-app https://youtu.be/_EOrSmjdOZQ

Пример 2: localhost/nextjs https://github.com/SpawnMetal/nextjs

Next.js — бесплатный и открытый JavaScript фреймворк, созданный поверх React.js для создания SSR-приложений.

Помогает создавать пользовательский интерфейс приложений (чаще всего, с помощью React, не придерживаясь его принципа — SPA (Single Page Application)).

SSR — принцип, используемый Next.js. Переводится с английского языка как «Отрисовка на стороне сервера». SSR помогает снизить нагрузку на устройство, ведь большинство операций производимых в приложении, происходит на сервере, а не на устройстве пользователя.

SSR также помогает улучшить SEO, так как в обычном подходе, который использует React (подход SPA), все отрисовывается на стороне клиента (браузера), поэтому код страниц подгружается когда пользователь заходит на страницу, но робот поисковых систем может только просмотреть изначальный код страницы, ещё не обработанный React.

SSR помогает избежать эту проблему изначальной загрузкой контента на всех страницах сайта.

- `<Link href=""><a>Текст</a></Link>`: реализует динамическую загрузку контента без перезагрузки страницы
  Папка pages - зарезервирована для создания страниц, адрес в строке сайта = названию файла
  filder/index.js - переход к странице в адресе folder, исполняющим файлом будет index.js
- `<style jsx global></style>`: для установки глобальных стилей, а не только для компонента. localhost/create-next-app/components/MainLayout.js

Пользовательский "Документ" pages/\_\_document.js для переосмысления и возможности переписать html документ https://nextjs.org/docs/advanced-features/custom-document

pages/\_\_app.js используется при инициализации страниц https://nextjs.org/docs/migrating/from-create-react-app

У error.module.scss после обработки next локализует стили за счёт .module в названии файла
next-env.d.ts - namespace описаны некоторые параметры для работы с next. `<reference types="next/types/global" />` означает, что ненужно импортировать React в те файлы, где используется jsx

getServerSideProps серверная функция. export default отрабатывает на сервере при открытии страницы в адресной строке для предварительной отрисовки - getServerSideProps + export default на клиенте и сервере. Переход на страницу из другой - getServerSideProps + export default только на клиенте

### Express

`#Express`

- `npm install express-validator`: An express.js middleware for validator. Для проверки полей на валидацию https://www.npmjs.com/package/express-validator

```
npm i express
```

https://developer.mozilla.org/en-US/docs/Learn/Server-side/Express_Nodejs/Introduction

Используется для роутинга, http-запросов, поднятия сервера и т. п.

Express.js, или просто Express, фреймворк web-приложений для Node.js, реализованный как свободное и открытое программное обеспечение под лицензией MIT. Он спроектирован для создания веб-приложений и API.

Де-факто является стандартным каркасом для Node.js.

### Node.js

`#Node.js`

https://Node.js.org/ru/

Node.js - программная платформа, основанная на движке V8 (транслирующем JavaScript в машинный код runtime), превращающая JavaScript из узкоспециализированного языка в язык общего назначения.

runtime - Значит, что если процесс в оперативке запущен, то он откликается на команды, иначе нет.
Документация по зависимостям https://Node.js.org/ru/docs/meta/topics/dependencies/

Пример проекта localhost/nodejs https://github.com/SpawnMetal/nodejs

- `node --version`: версия Node.js
- `node файл`: выполнение скрипта

Область видимости верхнего уровня в Node не является глобальной областью видимости

Сервер Node.js без фреймворка https://developer.mozilla.org/ru/docs/Learn/Server-side/Node_server_without_framework

SyntaxError: Cannot use import statement outside a module

Решение: Добавить в package.sjon "type": "module", чтобы заработал import

#### npm

`#npm`

https://www.npmjs.com

npm - node пакетный менеджер

https://habr.com/ru/post/133363/

- `npm init`: инициализировать проект, -y параметр для инициализации без вопросов. Затем npm i - установит все модули и зависимости из package.json, поэтому node_modules качать отдельно никому и никуда не нужно
- `npm run command`: команду получает из package.json параметр "scripts" текущей папки

Если npm run command "npm run start --prefix client", command находится в другой папке, то в команду добавляется --prefix с путём к папке client

Для запуска нескольких приложений, например клиента и сервера, в json используется параметр пакета concurrently: "dev": "concurrently \"npm run server\" \"npm run client\""

- `npm -v`: версия npm
- `npm install package_name`: установка пакета package_name локально. За место install можно просто i. Несколько пакетов перечисляются через пробел
- `npm install http-server -g`: установка пакета package_name глобально
- `npm show package_name version`: установленная версия пакета
- `npm view package_name version`: доступная версия пакета на сервере
- `npm view package_name`: информация о пакете
- `--save, --save-dev либо -D`: пакет установленный с помощью данного параметра, будет доступен только для разработки, добавлен в devDependencies

dependencies - зависимости, которые идут в package.json dependencies, затем если зайти в папку с данным названием внутри node_modules и открыть там package.json, то будут отображены другие установленные пакеты в dependencies и так далее по дереву.

- `npm uninstall package_name -g`:
- `npm i nodemon`: динамическое обновление сайта при внесении изменения в код, используется для разработки и запускается с помощью команды nodemon script.js

Предшествующее сообщение в консоли сервера: [nodemon] app crashed - waiting for file changes before starting...

Ошибка: Proxy error: Could not proxy request /api/auth/register from localhost:3000 to http://localhost:5000/

Решение: Не смог приконнектиться к БД, исправить доступ к БД и перезапустить сервер

- `npm i concurrently`: для одновременного запуска скриптов, например backend и frontend
- `npm i config`: пакет для работы с конфигурационным файлом. Создаётся папка config в которой default.json и production.json https://www.npmjs.com/package/config
- `npm i request-ip`: Получени ip клиента на сервере https://www.npmjs.com/package/request-ip
- `npm i ai-switcher-translit`: Смена раскладки и транслит https://github.com/alexanderkx/ai-switcher-translit
- `npm i bcryptjs`: Библиотека для шифрования / хеширования https://www.npmjs.com/package/bcryptjs
- `npm i jsonwebtoken`: #Токен jsonwebtoken библиотека для генерации веб-токенов JSON https://www.npmjs.com/package/jsonwebtoken
- `npm install materialize-css@next`: Materialize, Material Design https://materializecss.com/
- `npm i shortid`: Сокращение ссылок https://www.npmjs.com/package/shortid
- `npm install --save-dev cross-env`: Добавление кросс-операционных переменных для запуска скрипта, настройки прописываются у команд в package.json - scripts https://www.npmjs.com/package/cross-env
- `npm install -g json-server`: Поддельный REST API. Запуск сервера с db: json-server --watch db.json --port 4200 --delay 450 (сокращённо: json-server -w db.json -p 4200 -d 450) https://www.npmjs.com/package/json-server
- `npm i --save isomorphic-unfetch`: Серверный fetch https://www.npmjs.com/package/isomorphic-fetch
- `npm i nextjs-progressbar`: Индикатор загрузки https://www.npmjs.com/package/nextjs-progressbar

typescript typescriptreact
https://www.npmjs.com/package/typescript
https://www.npmjs.com/package/@types/react
npm install --save-dev typescript @types/react

- `npm install dotenv --save`: Dotenv - загружает переменные среды из .env файла process.env. `require('dotenv').config()` л ибо `import \* as dotenv from 'dotenv'`, затем `dotenv.config()`. https://www.npmjs.com/package/dotenv
- `npm i @material-ui/core`: #MaterialUI https://www.npmjs.com/package/@material-ui/core
- `npm i redux`: #Redux https://www.npmjs.com/package/redux
- `npm install react-redux`: Официальные привязки React для #Redux https://www.npmjs.com/package/react-redux
- `npm i redux-thunk`: #Redux #middleware для работы с асинхроном https://www.npmjs.com/package/redux-thunk
- `npm i redux-logger`: #Регистратор для #Redux https://www.npmjs.com/package/redux-logger
- `npm install redux-devtools-extension`: Расширение Redux DevTools. Например applyMiddleware, который позволяет диспатчить асинхроны. store = createStore(rootReducer, applyMiddleware(thunk, logger)) https://www.npmjs.com/package/redux-devtools-extension
- `npm i mobx mobx-react-lite`: MobX. Хранилище состояний, lite пакет для функциональных компонентов
  clipboard-copy
  `npm install clipboard-copy`: Копирование в буфер, подключать через require https://www.npmjs.com/package/clipboard-copy

##### Ошибки при установке пакета

###### 1

N:\web\htdocs_php5\php_site\files\11736>npm i --save-dev @babel/core @babel/cli

npm WARN optional SKIPPING OPTIONAL DEPENDENCY: fsevents@~2.3.1 (node_modules\chokidar\node_modules\fsevents):

npm WARN notsup SKIPPING OPTIONAL DEPENDENCY: Unsupported platform for fsevents@2.3.2: wanted {"os":"darwin","arch":"any"} (current: {"os":"win32","arch":"x64"})

npm WARN interactive_instructions@1.0.0 No repository field.

npm ERR! Maximum call stack size exceeded

npm ERR! A complete log of this run can be found in:

npm ERR! C:\Users\kushkov-pa.ALPHA\AppData\Roaming\npm-cache_logs\2021-03-25T04_21_28_748Z-debug.log

Решение, обновить файл с зависимостями: npm i --package-lock-only

Если не поможет, удалить node_modules и заново установить все пакеты

###### 2

npm ERR! code ENOSELF

npm ERR! Refusing to install package with name "mobx" under a package

npm ERR! also called "mobx". Did you name your project the same

npm ERR! as the dependency you're installing?

Переименовать name в package.json, имя проекта не должно называться так же, как зависимость

#### npx

`#npx`

npx помогает нам избежать версий, проблем с зависимостями и установки ненужных пакетов, которые мы просто хотим попробовать.

Он также предоставляет простой и понятный способ выполнения пакетов, команд, модулей и даже списков и репозиториев GitHub.

- `npx package_name`: установка пакета с именем name локально
- `npm v create-react-app`: Вывод инфы о пакете и тегах dist-tags, например в списке будет next:
- `npx create-react-app@next sandbox`

npx временно установит следующую версию create-react-app, а затем запустит приложение и установит его зависимости.

После установки мы можем перейти к приложению следующим образом:

cd sandbox

и затем запустите его с помощью этой команды: `npm start`

Зачастую асинхронные методы из установленных пакетов пишутся без приписки Sync

В callback первый параметр всегда является содержанием информации об ошибке

## Stacks

### MERN

`MERN`

Стек MERN - это JavaScript-стек, разработанный для упрощения процесса разработки. MERN включает в себя четыре компонента с открытым исходным кодом: [MongoDB](#MongoDB), [Express](#Express), [React](#React) и [Node.js](#Node.js).

Пример localhost\mern-course https://github.com/SpawnMetal/mern-course

https://youtu.be/ivDjWYcKDZI

Локально находится в папке mern-course

Запуск клиента и сервера для разработки: npm run dev

**Публикация на хостинге:**

Домен взят на https://2domains.ru

Хостинг, прост в настройках и поддерживает node, взят на https://vscale.io

Рекомендованная ОС - Ubuntu

512 МБ ОЗУ - мало, нужно больше

Через SSH Putty ходим, обновляем всё ПО sudo apt update, ставим Git, клонируем, гуглим установку Node.js

npm run client:install - установит node_modules для клиента

Билдим клиент npm run client:build

Настроить config/production.json на хостинге

Настроить в админке мерна ip сервера для доступа к БД

Чтобы при закрытии консоли сервер не вырубался ставим глобально npm install pm2 -g

Запускаем находясь в папке с проектом: pm2 start npm -- start

Material Design ставится соответственно в папку client
"proxy": "http://localhost:5000", прописывается в client/package.json, чтобы запросы с клиента шли по серверной ссылке, на сервер, а не на клиент

## NoSQL

### MongoDB

`#MongoDB`

```
npm i mongoose
```

https://www.mongodb.com

MongoDB — документо ориентированная система управления базами данных, не требующая описания схемы таблиц. Считается одним из классических примеров NoSQL-систем, использует JSON-подобные документы и схему базы данных.

Применяется в веб-разработке, в частности, в рамках JavaScript-ориентированного стека MEAN.

Пример кода: C:\program files\open server\ospanel\domains\localhost\mern-course

### Redis

`#Redis`

## Принципы

`#Принципы`

### Принципы, схемы и подходы программирования

#### Соглашения JavaScript

`#Соглашения`

camelCase для переменных и методов.

PascalCase для типов и классов.

UPPER_CASE_SNAKE_CASE для констант.

Соглашения React: PascalCase используется для названий компонентов, определённых файлов, например файлов моделей.

Хуки в React: use вначале названия хука. useName

#### MVC

`#MVC`

https://ru.wikipedia.org/wiki/Model-View-Controller

https://habr.com/ru/company/ruvds/blog/333856/

https://learn.javascript.ru/classes

Model-View-Controller (MVC, «Модель-Представление-Контроллер», «Модель-Вид-Контроллер») — схема разделения данных приложения, пользовательского интерфейса и управляющей логики на три отдельных компонента: модель, представление и контроллер — таким образом, что модификация каждого компонента может осуществляться независимо[1].

Модель (Model) предоставляет данные и реагирует на команды контроллера, изменяя своё состояние[1].

Представление (View) отвечает за отображение данных модели пользователю, реагируя на изменения модели[1].

Контроллер (Controller) интерпретирует действия пользователя, оповещая модель о необходимости изменений[1].

##### Модель

`#Модель #Model`

Модель предоставляет данные и методы работы с ними: запросы в базу данных, проверка на корректность. Модель не зависит от представления (не знает как данные визуализировать) и контроллера (не имеет точек взаимодействия с пользователем) просто предоставляя доступ к данным и управлению ими.

Модель строится таким образом, чтобы отвечать на запросы, изменяя своё состояние, при этом может быть встроено уведомление «наблюдателей».

Модель, за счёт независимости от визуального представления, может иметь несколько различных представлений для одной «модели».

Модель PenguinModel отвечает за работу с данными. В клиентском JS это означает выполнение Ajax-операций. Одно из преимуществ шаблона MVC заключается в том, что всё взаимодействие с источником данных,
например — с сервером, сосредоточено в одном месте. Такой подход помогает программистам, которые не знакомы с проектом, разобраться в нём. Модель в этом шаблоне проектирования занята исключительно работой
с JSON или объектами, которые поступают с сервера.

##### Представление

`#Представление #View`

Представление отвечает за получение необходимых данных из модели и отправляет их пользователю. Представление не обрабатывает введённые данные пользователя.

Представление PenguinView взаимодействует с DOM. DOM — это API браузера, с помощью которого работают с HTML. В MVC только представление отвечает за изменения DOM.

Представление может выполнять подключение обработчиков событий пользовательского интерфейса, но обработка событий — прерогатива контроллера. Основная задача, решаемая представлением — управлять тем,
что пользователь видит на экране. В нашем проекте представление будет выполнять манипуляции с DOM, используя JavaScript.

##### Контроллер

`#Контроллер #Controller`

Контроллер обеспечивает «связь» между пользователем и системой. Контролирует и направляет данные от пользователя к системе и наоборот. Использует модель и представление для реализации необходимого действия.

Контроллер PenguinController занимается обработкой событий и служит посредником между представлением и моделью. Он выясняет, что произошло, когда пользователь выполняет некое действие
(например, щёлкает по кнопке или нажимает клавишу на клавиатуре). Логика клиентских приложений может быть реализована в контроллере. В более крупных системах, в которых нужно обрабатывать множество событий,
этот элемент можно разбить на несколько модулей. Контроллер является входной точкой для событий и единственным посредником между представлением и данными.

#### SOLID

`#SOLID`

SOLID - принцип объектно-ориентированного программирования

https://web-creator.ru/articles/solid

Моё понимание:

1. Каждый объект со своей единственной обязанностью и все сервисы этого класса её сопровождают. Это не догма, например паттерн ActiveRecord её нарушает и делает это правильно.

2. Реализовывается класс, например интерфейс и больше код не дорабатывается. Новые классы уже наследуются и в них уже содержатся дополнительные функции.

3. Наследуемый класс не должен переписывать родителя и при замене обращений к методам с родителя на дочерний, проблем возникнуть не должно. Это не догма, так как более ресурсоёмко.
4. Раздельный интерфейс (React), подобно П1.

5. В интерфейсе вызывается серверный класс, затем необходимо например реализовать функционал авторизации, который нужно реализовать отдельно не в серверном, вызвать тоже в интерфейсе и передать серверу.

SOLID — это аббревиатура пяти основных принципов проектирования в объектно-ориентированном программировании — Single responsibility, Open-closed, Liskov substitution, Interface segregation и Dependency inversion.

В переводе на русский: принципы единственной ответственности, открытости / закрытости, подстановки Барбары Лисков, разделения интерфейса и инверсии зависимостей

Аббревиатура SOLID была предложена Робертом Мартином, автором нескольких книг, широко известных в сообществе разработчиков. Эти принципы позволяют строить на базе ООП масштабируемые и сопровождаемые программные продукты с понятной бизнес-логикой.

Расшифровка:

Single responsibility — принцип единственной ответственности

Open-closed — принцип открытости / закрытости

Liskov substitution — принцип подстановки Барбары Лисков

Interface segregation — принцип разделения интерфейса

Dependency inversion — принцип инверсии зависимостей

Принцип единственной обязанности / ответственности (single responsibility principle / SRP) означает, что каждый объект должен иметь одну обязанность и эта обязанность должна быть полностью инкапсулирована в класс. Все его сервисы должны быть направлены исключительно на обеспечение этой обязанности.

Принцип открытости / закрытости (open-closed principle / OCP) декларирует, что программные сущности (классы, модули, функции и т. п.) должны быть открыты для расширения, но закрыты для изменения. Это означает, что эти сущности могут менять свое поведение без изменения их исходного кода.

Принцип подстановки Барбары Лисков (Liskov substitution principle / LSP) в формулировке Роберта Мартина: «функции, которые используют базовый тип, должны иметь возможность использовать подтипы базового типа не зная об этом».

Принцип разделения интерфейса (interface segregation principle / ISP) в формулировке Роберта Мартина: «клиенты не должны зависеть от методов, которые они не используют». Принцип разделения интерфейсов говорит о том, что слишком «толстые» интерфейсы необходимо разделять на более маленькие и специфические, чтобы клиенты маленьких интерфейсов знали только о методах, которые необходимы им в работе. В итоге, при изменении метода интерфейса не должны меняться клиенты, которые этот метод не используют.

Принцип инверсии зависимостей (dependency inversion principle / DIP) — модули верхних уровней не должны зависеть от модулей нижних уровней, а оба типа модулей должны зависеть от абстракций; сами абстракции не должны зависеть от деталей, а вот детали должны зависеть от абстракций.

#### KISS

`#KISS`

KISS — Принцип программирования - делайте вещи проще

https://web-creator.ru/articles/kiss

KISS — это принцип проектирования и программирования, при котором простота системы декларируется в качестве основной цели или ценности. Есть два варианта расшифровки аббревиатуры: «keep it simple, stupid» и более корректный «keep it short and simple».

В проектировании следование принципу KISS выражается в том, что:

не имеет смысла реализовывать дополнительные функции, которые не будут использоваться вовсе или их использование крайне маловероятно, как правило, большинству пользователей достаточно базового функционала, а усложнение только вредит удобству приложения;

не стоит перегружать интерфейс теми опциями, которые не будут нужны большинству пользователей, гораздо проще предусмотреть для них отдельный «расширенный» интерфейс (или вовсе отказаться от данного функционала);

бессмысленно делать реализацию сложной бизнес-логики, которая учитывает абсолютно все возможные варианты поведения системы, пользователя и окружающей среды, — во-первых, это просто невозможно, а во-вторых, такая фанатичность заставляет собирать «звездолёт», что чаще всего иррационально с коммерческой точки зрения.

В программировании следование принципу KISS можно описать так:
не имеет смысла беспредельно увеличивать уровень абстракции, надо уметь вовремя остановиться;

бессмысленно закладывать в проект избыточные функции «про запас», которые может быть когда-нибудь кому-либо понадобятся (тут скорее правильнее подход согласно принципу YAGNI);

не стоит подключать огромную библиотеку, если вам от неё нужна лишь пара функций;

декомпозиция чего-то сложного на простые составляющие — это архитектурно верный подход (тут KISS перекликается с DRY);

абсолютная математическая точность или предельная детализация нужны не всегда — большинство систем создаются не для запуска космических шаттлов, данные можно и нужно обрабатывать с той точностью, которая достаточна для качественного решения задачи, а детализацию выдавать в нужном пользователю объёме, а не в максимально возможном объёме.

Также KISS имеет много общего c принципом разделения интерфейса из пяти принципов SOLID, сформулированных Робертом Мартином.

#### DRY

`#DRY`

DRY - Принцип программирования — don’t repeat yourself / не повторяйте себя

https://web-creator.ru/articles/dry

Следование принципу DRY приводит к модульной архитектуре приложения и к чёткому разделению ответственности за бизнес-логику между программными классами. А это — залог сопровождаемой архитектуры.

Хотя чаще не DRY приводит к модульности, а уже модульность, в свою очередь, обеспечивает принципиальную возможность соблюдения этого принципа в больших проектах.

В проектировании DRY тоже имеет место — доступ к конкретному функционалу должен быть доступен в одном месте, унифицирован и сгруппирован по какому-либо принципу, а не «разбросан» по системе в произвольных вариациях.
Этот подход пересекается с принципом единственной ответственности из пяти принципов SOLID, сформулированных Робертом Мартином.

#### YAGNI

`#YAGNI`

YAGNI - Принцип программирования — «Вам это не понадобится»

https://web-creator.ru/articles/yagni

Если упрощенно, то следование данному принципу заключается в том, что возможности, которые не описаны в требованиях к системе, просто не должны реализовываться.

Это позволяет вести разработку, руководствуясь экономическими критериями — Заказчик не должен оплачивать ненужные ему функции, а разработчики не должны тратить своё оплачиваемое время на реализацию того, что не требуется.

Основная проблема, которую решает принцип YAGNI — это устранение тяги программистов к излишней абстракции, к экспериментам «из интереса» и к реализации функционала, который сейчас не нужен, но,
по мнению разработчика, может либо вскоре понадобиться, либо просто будет полезен, хотя в реальности такого очень часто не происходит.

Принципы YAGNI и KISS очень похожи, если KISS нацелен на упрощение и полезен в плане работы с теми требованиями, которые имеют место быть,
то YAGNI более категоричен и применяется для ограждения проектов по разработке ПО от «размывания» их рамок.

Подход к реализации проектов строго по ТЗ верен с нескольких ракурсов. Заказчик не должен платить за то, что ему не надо, а продукт должен быть максимально сопровождаем и его качество не должно страдать от интеграции ненужных функций.

#### Паттерны проектирования

`#Паттерны проектирования #design #pattern`

https://habr.com/ru/company/ruvds/blog/427293

В сфере разработки программного обеспечения паттерн проектирования (design pattern) — это повторяемая архитектурная конструкция, представляющая собой решение проблемы проектирования в рамках некоторого часто возникающего контекста. Паттерны проектирования представляют собой обобщение опыта профессиональных разработчиков ПО. Паттерн проектирования можно рассматривать как некий шаблон, в соответствии с которым пишут программы.
Определения далее содержатся на примере в папке localhost/patterns https://github.com/SpawnMetal/patterns

- `Модуль (Module)`: (patterns/pattern_module.js), вызывается при создании, обращение происходит к возвращаемым свойствам и функциям объекта, у возвращаемой функции создаётся замкнутая функция
- `Открытый модуль (Revelating Module)`: (patterns/pattern_revealing_module.js), вызывается при создании, обращение происходит к возвращаемым свойствам и функциям объекта
- `Синглтон (Singleton)`: (patterns/pattern_singleton.js), одиночка, существует в единственном экземпляре. Если объект уже имеется, возвращает его же, иначе создаёт новый.
- `Фабрика (Factory)`: (patterns/pattern_factory.js), копипаст по созданию шаблонных классов в зависимости от специфики (установленного свойства) с определением значений по умолчанию, если требуется. В общем в одном, первом вызываемом классе конструктор с условием по созданию необходимого класса.
- `Декоратор (Decorator)`: (patterns/pattern_decorator.js), создаётся шаблонный класс, затем в функциях меняются значения шаблона
- `Creational Design Patterns`: паттерны для создания объектов / классов https://youtu.be/YJVj4XNASDk
  - `Constructor (Конструктор)`: (patterns/1 creational/1_constructor.js), конструктор класса за место прототипа
  - `Factory (Фабрика)`: (patterns/1 creational/2_factory.js), множество повторяющихся классов с одинаковыми свойствами
  - `Prototype (Прототип)`: (patterns/1 creational/3_prototype.js), прототип объекта, по образу и подобию которого создаётся новый и у этого нового **proto** будет равен объекту родителя, хотя сами объекты не будут равны
  - `Singleton (Синглтон)`: (patterns/1 creational/4_sigleton.js), вызов конструктора создаёт объект класса только один раз, затем будет возвращать ранее созданный
- `Structural Design Pattern`: создание нового функционала для существующих объектов, не затрагивая уже существующего https://youtu.be/YJVj4XNASDk
  - `Adapter (Адаптер)`: (patterns/2 structural/5_adapter.js), позволяет интегрировать функционал например старого интерфейса в новый, не ломая всё приложение
  - `Decorator (Декоратор)`: (patterns/2 structural/6_decorator.js), позволяет навесить новый функционал на существующий объект класса
  - `Facade (Фасад)`: (patterns/2 structural/7_facade.js), создание классов через if type, например как библиотека JQuery, куда подавалось что угодно в селектор $(значение). Это значение ведь не может быть ключом объекта, чтобы реализовать как у фабрики
  - `Flyweight (Флайвейт)`: (patterns/2 structural/8_flyweight.js), пресекает повторную загрузку данных, кэширует, сохраняет в памяти и т д
  - `Proxy (Прокси)`: (patterns/2 structural/9_proxy.js), избавляет веб сервер от лишних запросов на сервер, расставляет ловушки, валидацию
- `Behaviour Design Pattern`: поведенческие паттерны для налаживания коммуникации между существующими сущностями разного типа, API, версии https://youtu.be/YJVj4XNASDk
  - `Chain of Responsibility (Цепочка обязанностей)`: (patterns/3 behaviour/10_chain_of_responsebility.js), позволяет строить цепочки вызовов функций, как у JQuery $(значение).метод1.метод2.метод3
  - `Command (Комманд)`: (patterns/3 behaviour/11_command.js), вызов функций, название которых передано в качестве строки и будет записано в некий массив вызванных команд / функций
  - `Iterator (Итератор)`: (patterns/3 behaviour/12_iterator.js), необходим для получения последовательной информации
  - `Mediator (Медиатор)`: (patterns/3 behaviour/13_mediator.js), в первую очередь позволяет выстраивать плотную и тесную коммуникацию различных типов, предоставляет централизованную абстракцию, позволяющую объектам взаимодействовать через друг друга
  - `Observer (Обсервер / Наблюдатель)`: (patterns/3 behaviour/14_observer.js), объекты подписываются на изменения другого и соответствующе реагируют
  - `State (Стейт / Состояние)`: (patterns/3 behaviour/15_state.js), верхнеуровневый класс будет менять состояние относящееся к подклассам
  - `Strategy (Стратегия)`: (patterns/3 behaviour/16_strategy.js), оболочка / семейство алгоритмов, которые наследуют объекты в разные алгоритмы и интерфейсы, не изменяя их. В нём просто вызываются функции другого класса
  - `Template (Темплейт / Шаблон)`: (patterns/3 behaviour/17_template.js), определяет скелет будущего алгоритма, а дочерние реализуют конкретный функционал на основании скелета

## Определения

`#Определения`

### SSR

`#SSR`

https://blog.vverh.digital/2020/what-is-it-ssr-chto-takoe/

SSR – (анг. аббревиатура от Server Side Rendering) это технология, которая позволяет, с помощью Node.js, запускать JavaScript код на сервере (а не в браузере как обычно) и готовый результат отправлять пользователю, избегая лишней нагрузки на его браузер и компьютер.

Зачем нужен SSR:

В первую очередь, для оптимизации скорости работы сайта и SEO продвижения.

### SEO

`#SEO`

https://ru.wikipedia.org/wiki/Поисковая_оптимизация

Поисковая оптимизация (англ. search engine optimization, SEO) — комплекс мероприятий по внутренней и внешней оптимизации для поднятия позиций сайта в результатах выдачи поисковых систем по определённым запросам пользователей, с целью увеличения сетевого трафика (для информационных ресурсов) и потенциальных клиентов (для коммерческих ресурсов) и последующей монетизации (получение дохода) этого трафика. SEO может быть ориентировано на различные виды поиска, включая поиск информации, товаров, услуг, изображений, видеороликов, новостей и специфические отраслевые поисковые системы.

### middleware

`#middleware`

[Middleware][middleware]

[Написание кода промежуточных обработчиков для использования в приложениях Express][express-middleware]
Функции промежуточной обработки (middleware) - это функции, имеющие доступ к объекту запроса (req), объекту ответа (res) и к следующей функции промежуточной обработки в цикле “запрос-ответ” приложения.
Следующая функция промежуточной обработки, как правило, обозначается переменной next.

[middleware]: https://developer.mozilla.org/en-US/docs/Glossary/Middleware
[express-middleware]: https://expressjs.com/ru/guide/writing-middleware.html#:~:text=%D0%A4%D1%83%D0%BD%D0%BA%D1%86%D0%B8%D0%B8%20%D0%BF%D1%80%D0%BE%D0%BC%D0%B5%D0%B6%D1%83%D1%82%D0%BE%D1%87%D0%BD%D0%BE%D0%B9%20%D0%BE%D0%B1%D1%80%D0%B0%D0%B1%D0%BE%D1%82%D0%BA%D0%B8%20(middleware)%20%2D,%D0%BA%D0%B0%D0%BA%20%D0%BF%D1%80%D0%B0%D0%B2%D0%B8%D0%BB%D0%BE%2C%20%D0%BE%D0%B1%D0%BE%D0%B7%D0%BD%D0%B0%D1%87%D0%B0%D0%B5%D1%82%D1%81%D1%8F%20%D0%BF%D0%B5%D1%80%D0%B5%D0%BC%D0%B5%D0%BD%D0%BD%D0%BE%D0%B9%20next%20.
